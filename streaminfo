#!/usr/bin/ruby
# microcast streaminfo tool
# Copyright(c) 2011 by Christopher Abad
# mailto:aempirei@gmail.com
# aim:goim?screenname=ambient+empire
# http://www.twentygoto10.com
# git://github.com/aempirei/microcast.git

require 'rubygems'
require 'getoptlong'
require 'socket'

PROGRAM = 'streaminfo'
VERSION = '1.0'
ARG0 = File.basename(__FILE__)

DFLPORT = 80
DFLPATH = '/'

def parse_url(url)

	if url =~ /^(https?):\/\/([-\w.]+)(?::(\d+))?(.+)?/

		protocol = $1
		host = $2
		port = $3.nil? ? DFLPORT : $3
		path = $4.nil? ? DFLPATH : $4

		return [ protocol, host, port, path ]
	end

	return nil
end

class ZConfig

	VERSION = [ 'MPEG 2.5', 'reserved', 'MPEG 2', 'MPEG 1' ]
	LAYER = [ 'reserved', 'Layer III', 'Layer II', 'Layer I' ]
	CRC16 = [ 'yes', 'no' ]
	BITRATE = [
		[ lambda { |v,l| [ 3 ].include?(v) and [ 3 ].include?(l) }, [ 'free', 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 'bad' ] ],
		[ lambda { |v,l| [ 3 ].include?(v) and [ 2 ].include?(l) }, [ 'free', 32, 48, 56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384, 'bad' ] ],
		[ lambda { |v,l| [ 3 ].include?(v) and [ 1 ].include?(l) }, [ 'free', 32, 40, 48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 'bad' ] ],
		[ lambda { |v,l| [0,2].include?(v) and [ 3 ].include?(l) }, [ 'free', 32, 48, 56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256, 'bad' ] ],
		[ lambda { |v,l| [0,2].include?(v) and [1,2].include?(l) }, [ 'free',  8, 16, 24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160, 'bad' ] ]
	]

	SAMPLERATE = [
		[ 11025, 12000,  8000, 'reserved' ], # MPEG 2.5
		[ 'bad', 'bad', 'bad', 'reserved' ], # reserved
		[ 22050, 24000, 16000, 'reserved' ], # MPEG 2
		[ 44100, 48000, 32000, 'reserved' ], # MPEG 1
	]

	PADDING = [ 'no', 'yes' ]
	PRIVACY = [ 'no', 'yes' ]
	MODE = [ 'stereo', 'joint stereo', 'dual mono', 'single mono' ]
	COPYRIGHT = [ 'no', 'yes' ]
	ORIGINAL = [ 'no', 'yes' ]
	EMPHASIS =  [ 'none', '50/15ms', 'reserved', 'CCIT J.17' ]

	FRAME_HEADER_SZ = 4
	FRAME_CRC16_SZ = 2

	attr_accessor :protocol
	attr_accessor :host
	attr_accessor :port
	attr_accessor :path
	attr_accessor :url
	attr_accessor :socket
	attr_accessor :options
	attr_accessor :frames
	attr_accessor :datastream

	def get_bitrate(v,l,br)

		BITRATE.each { |f,brs| return brs[br] if f.call(v,l) }

		return nil
	end

	def get_frame_size(l,br,sr,padding)

		return 'bad' unless br.is_a?(Numeric) and sr.is_a?(Numeric) and padding.is_a?(Numeric)

		if [1,2].include?(l)
			return (144 * br * 1000 / sr) + padding
		elsif [3].include?(l)
			return ((12 * br * 1000 / sr) + padding) * 4
		else
			return 'bad'
		end
	end

	def initialize
		@options = []
		@frames = []
		@datastream = ''
	end

	def startup

		raise 'no url specified' if @url.nil?

		@protocol, @host, @port, @path = parse_url @url

		raise 'url invalid' if @protocol.nil?
		
		# connect socket

		@socket.close unless @socket.nil?

		@socket = TCPSocket.open(@host, @port)

		# register at_exit

		Kernel.at_exit do
			@socket.close unless ( @socket.nil? or @socket.closed? )
		end

		# register SIGINT handler

		Kernel.trap('INT') do |signo|
			Kernel.trap(signo, 'SIG_IGN')
			puts "captured interrupt, exiting"
			exit
		end

		return true
	end

	def resp_ok?(line)

		raise 'no response received' if line.nil?

		line.chomp!

		return true if line =~ /^HTTP\/1\.[01]\s+200\s+OK\s*$/

		return false
	end

	def get_options

		options = []

		while true
			line = @socket.readline
			raise 'getting options failed' if line.nil?
			line.chomp!
			break if line == ''
			options << line
		end

		return options.inject({}) do |a,option|
			a[$1] = $2 if option =~ /^([^:]+):\s*(.*)/
			a
		end
	end

	def request

		request_data = sprintf("GET %s HTTP/1.1\r\nHost: %s\r\nIcy-MetaData:1\r\n\r\n", @path, @host)

		@socket.write request_data

		if resp_ok?(@socket.readline)
			
			@options = get_options

			raise 'metaint missing from options' unless @options.has_key? 'icy-metaint'

			@metaint = @options['icy-metaint'].to_i

			raise 'metaint is not a positive integer' if @metaint < 1

			return true
		end

		return false
	end

	def get_frame_header_fields(data32)

		frame_header = sprintf("%b", data32.unpack('N').first)

		return [ [0,11],[11,2],[13,2],[15,1],[16,4],[20,2],[22,1],[23,1],[24,2],[26,2],[28,1],[29,1],[30,2] ].map do |range|
			Integer ('0b' + frame_header[*range])
		end
	end

	def get_frame_header_offset(data)

		skip = 0

		until (data[skip + 0].ord == 0xff) and (data[skip + 1].ord >= 0xf0) and (data[skip + 1].ord <= 0xff)
			skip += 1
			return nil if skip + FRAME_HEADER_SZ == data.length
		end

		return skip
	end

	def get_hexdump(data)
		lines = []
		data.split(//).map { |b| sprintf('%02x', b.ord) }.each_slice(32) { |xs| lines << xs.join(' ') }
		return lines.join("\n")
	end

	def frame_header_valid?(frame_header)
		return false if ( not frame_header.values.grep(/^(reserved|bad)$/).empty? )
		return false if frame_header['layer'] != 'Layer III'
		return true
	end

	def has_frame?(data)
		return ( not get_frame_header_offset(data).nil? )
	end

	def get_frames(data)

		frames = []

		while has_frame?(data)
			frame,data = get_frame(data)
			break if frame.nil?
			frames << frame
		end

		return [ frames, data ]
	end

	def get_frame(data)

		postponed = [ nil, data ]

		return postponed if data.size < FRAME_HEADER_SZ

		# puts get_hexdump(data[0,384])

		skipped_data = ''

		while true do

			skip = get_frame_header_offset(data)

			return postponed if skip.nil?

			skipped_data += data.slice!(0,skip)

			frame_header_bytes = data.slice(0,FRAME_HEADER_SZ)

			sync,version,layer,crc16off,br,sr,padding,privacy,mode,me,copyright,original,emphasis = get_frame_header_fields(frame_header_bytes)

			bitrate = get_bitrate(version,layer,br)

			frame_header = {
				'version'     => VERSION[version],
				'layer'       => LAYER[layer],
				'crc-16'      => CRC16[crc16off],
				'bit-rate'    => bitrate,
				'sample-rate' => SAMPLERATE[version][sr],
				'padding'     => PADDING[padding],
				'privacy'     => PRIVACY[privacy],
				'mode'        => MODE[mode],
				'copyright'   => COPYRIGHT[copyright],
				'original'    => ORIGINAL[original],
				'emphasis'    => EMPHASIS[emphasis],
				'frame-size'  => get_frame_size(layer, bitrate, SAMPLERATE[version][sr], padding), # FIXME: deal with the padding here
				'skip-size'   => skipped_data.size,
				'data'        => nil
			}

			# print_hash frame_header + "\n"

			if frame_header_valid? frame_header
				# remove the frame header and now data just contains the tail data which is already saved in frame_header_bytes
				data.slice!(0,FRAME_HEADER_SZ)
				break
			else
				# add one byte of the invalid frame header to the pre data so that it gets skipped next iteration
				skipped_data += data.slice!(0)
			end
		end

		if frame_header['crc-16'] == 'yes'
			# if the crc16 is not off then pull it from the tail data
			# put the data back and wait until later if theres not enough data
			return postponed if data.size < 2
			crc = data.slice!(0,FRAME_CRC16_SZ).unpack('n')
			frame_header['crc-16-value'] = crc
		end

		return [ frame_header, data ]
	end

	def read_meta
		sz = @socket.recv(1)
		raise 'meta header read failed' if sz.nil?
		sz = sz.ord * 16
		return recv_bytes(sz)
	end

	def recv_bytes(n)
		data = ''

		while data.size < n
			delta = @socket.recv(n - data.size)
			raise 'data read failed' if delta.nil?
			data += delta
		end

		return data
	end

	def each_meta(&block)
		loop do
			meta = next_meta()
			break if meta.nil?
			block.call meta
		end
	end

	def next_meta
		# get a data chunk based on the meta-int value

		@datastream += recv_bytes(@metaint)

		meta = read_meta()

		frames, @datastream = get_frames(@datastream)

		@frames += frames

		meta = meta.sub(/\0+$/, '').scan(/(\w+)=('[^']*'|"[^"]*");/).inject({}) do |acc,kv|
			kv[1] = $2 if kv[1] =~ /(['"])(.*)\1/
			acc[kv[0]] = kv[1]
			acc
		end

		return meta
	end
end

$config = ZConfig.new

OPTIONS = [
	[ [ '--url'    , '-u', GetoptLong::REQUIRED_ARGUMENT ], nil, 'url'            ],
	[ [ '--help'   , '-h', GetoptLong::NO_ARGUMENT       ], nil, 'help'           ],
	[ [ '--version', '-V', GetoptLong::NO_ARGUMENT       ], nil, 'version'        ]
]

def usage

	width = 20

	print "\n"
	
	version()

	print "\nusage: " + ARG0 + " [options]\n\n"

	OPTIONS.each do |option,arg,desc|

		( long, short, params ) = option
		
		str = [ long, short ].compact.join(', ') + ' '
		str += arg.to_s.upcase unless arg.nil?

		printf("\t%-*s%s", width, str, desc)
		printf(' (default: %s)', $config.send(arg)) unless arg.nil?
		print "\n"
	end

	print "\n"

end

def version
	puts PROGRAM + ' ' + VERSION
end

opts = GetoptLong.new(*OPTIONS.map { |x| x.first })

opts.each do |opt,arg|
	case opt
		when '--url'
			$config.url = arg
		when '--help'
			usage()
			exit
		when '--version'
			version()
			exit
	end
end

unless $config.startup
	puts "initialization failed"
	exit false
end

unless $config.request
	puts "stream request failed"
	exit false
end

def print_hash(hash)
	hash.each do |k,v|
		printf("%s: %s\n", k, v);
	end
end

print_hash $config.options

$config.each_meta do |meta|

	print_hash meta

	printf("frame-count: %d\n",  $config.frames.size)

	tally = 0
	pline = nil

	$config.frames.each do |f|

		line = sprintf("%s %s %3dKb/s %d5hz %s %s previous %d expected next %d crc-16 %s padding %s",
			f['version'], f['layer'], f['bit-rate'], f['sample-rate'], f['mode'], f['emphasis'], f['frame-size'], f['skip-size'], f['crc-16'], f['padding'])

		if line == pline
			tally += 1
		else
			printf("(%03d) %s\n", tally, pline) unless pline.nil?
			tally = 1
			pline = line
		end
	end

	$config.frames.clear
end
